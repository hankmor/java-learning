# 缓冲区Buffer

Buffer称为缓冲区。除了内容之外，缓冲区中包含几个参数：

1. 位置(position)：缓冲区的位置是要读取或写入的下一个元素的索引。 缓冲区的位置永远不会为负，也永远不会大于其界限。
2. 界限(limit)：缓冲区的界限是不应读取或写入的第一个元素的索引。 缓冲区的界限永远不会为负，也永远不会大于其容量。
3. 容量(capacity)：缓冲区中包含的元素个数，它永远不为负数且不会改变
4. 标记(mark)：缓冲区的标记是调用reset方法时其位置将重置到的索引

缓冲区每个子类都定义了两类get和put操作：

1. 相对操作从当前位置开始读取或写入一个或多个元素，然后将位置增加传输的元素数量。
   如果请求的传输超过界限，则相对获取操作会抛出BufferUnderflowException而相对放置操作会抛出BufferOverflowException ； 在任何一种情况下，都不会传输任何数据。
2. 绝对操作采用显式元素索引并且不影响位置。 如果索引参数超出界限，绝对获取和放置操作会抛出IndexOutOfBoundsException。

## 标记和重置

缓冲区的标记是调用reset方法时其位置将重置到的索引。标记并不总是被定义，但当它被定义时，它永远不会是负的，也永远不会大于位置。如果定义了标记，则在将位置或界限调整为小于标记的值时将丢弃该标记。如果未定义标记，则调用reset方法会导致抛出InvalidMarkException。

以下不变量适用于标记、位置、界限和容量值：0 <=标记<=位置<=界限<=容量

新创建的缓冲区始终具有零位置和未定义的标记。初始界限可能为零，也可能是某个其他值，具体取决于缓冲区的类型及其构造方式。新分配的缓冲区的每个元素都初始化为零。

## 清除、翻转和倒带

除了用于访问位置、界限和容量值以及用于标记和重置的方法之外，该类还定义了对缓冲区的以下操作：

1. clear：使缓冲区为新的通道读取或相对放置操作序列做好准备：它将位置设置为零，将界限设置为容量大小，并丢弃标记。
2. flip：使缓冲区为新的通道写入或相对获取操作序列做好准备：将界限设置为当前位置，然后将位置设置为零。如果定义了标记，则将其丢弃。
3. rewind：使缓冲区准备好重新读取它已经包含的数据：位置设置为零，标记被丢弃。

## 只读缓冲区

每个缓冲区都是可读的，但并非每个缓冲区都是可写的。 每个缓冲区类的变异方法被指定为可选操作，当在只读缓冲区上调用时将抛出ReadOnlyBufferException 。 只读缓冲区不允许更改其内容，但其标记、位置和界限值是可变的。
缓冲区是否为只读可以通过调用它的isReadOnly方法来确定。

## 线程安全

多个并发线程使用缓冲区是不安全的。 如果一个缓冲区被多个线程使用，那么对缓冲区的访问应该有适当的同步控制。

## 链式调用

此类中没有返回值的方法被指定为返回调用它们的缓冲区。这允许链式方法调用； 例如，语句序列

```java
b.flip(); 
b.position(23); 
b.limit(42); 
```

可以写为：`b.flip().position(23).limit(42);`

# ByteBuffer

ByteBuffer继承自Buffer，它是一个字节缓冲区。此类定义了对字节缓冲区的六类操作：

1. 读写单个字节的绝对和相对get和put方法；
2. 将此缓冲区中的连续字节序列传输到数组中的相对bulk get方法；
3. bulk put字节数组或其他一些字节缓冲区中的连续字节序列传输到此缓冲区的相对bulk put方法；
4. 读取和写入其他原始类型值的绝对和相对get和put方法，将它们转换为特定字节顺序的字节序列或从字节序列转换；
5. 创建视图缓冲区的方法，允许将字节缓冲区视为包含某些其他原始类型值的缓冲区； 和
6. compacting 、 duplicating和slicing字节缓冲区的方法。

字节缓冲区可以通过allocation （为缓冲区的内容分配空间）或通过wrapping现有字节数组wrapping到缓冲区中来创建。

## 直接与非直接缓冲区

字节缓冲区要么是直接的，要么是非直接的。 给定一个直接字节缓冲区，Java 虚拟机将尽最大努力直接在其上执行本机 I/O 操作。 也就是说，它将尝试避免在每次调用底层操作系统的本机 I/O
操作之前（或之后）将缓冲区的内容复制到（或从）中间缓冲区。

可以通过调用此类的allocateDirect工厂方法来创建直接字节缓冲区。 此方法返回的缓冲区通常比非直接缓冲区具有更高的分配和解除分配成本。 直接缓冲区的内容可能驻留在正常的垃圾收集堆之外，因此它们对应用程序内存占用的影响可能并不明显。
因此，建议将直接缓冲区主要分配给受底层系统本地 I/O 操作影响的大型、长期存在的缓冲区。 一般而言，最好仅在程序性能产生可衡量的增益时才分配直接缓冲区。

也可以通过mapping文件的区域直接mapping到内存来创建直接字节缓冲区。 Java 平台的实现可以选择支持通过 JNI 从本机代码创建直接字节缓冲区。
如果这些类型的缓冲区之一的实例引用了不可访问的内存区域，则尝试访问该区域将不会更改缓冲区的内容，并且会导致在访问时或稍后抛出未指定的异常时间。

字节缓冲区是直接的还是非直接的可以通过调用它的isDirect方法来确定。 提供此方法是为了可以在性能关键代码中完成显式缓冲区管理。

## 访问二进制数据

该类定义了读取和写入所有其他基本类型值的方法，除了boolean 。 根据缓冲区的当前字节顺序，原始值被转换为（或来自）字节序列，可以通过order方法检索和修改。 特定的字节顺序由ByteOrder类的实例表示。
字节缓冲区的初始顺序始终是BIG_ENDIAN 。

* BIG_ENDIAN: 低位优先，最重要的字节优先存储到低位的存储单元中。
* LITTLE_ENDIAN: 高位优先，最重要的字节优先存储到高位的存储单元中。

例如：00000000 01100001，BIG_ENDIAN排列后的二进制为00000000 01100001，而LITTLE_ENDIAN后为 01100001 00000000。

为了访问异构二进制数据，即不同类型的值序列，该类为每种类型定义了一系列绝对和相对的get和put方法。 例如，对于 32 位浮点值，此类定义：

```java
float  getFloat()
float  getFloat(int index)
void  putFloat(float f)
void  putFloat(int index, float f)
```

为char 、 short 、 int 、 long和double类型定义了相应的方法。 绝对get和put方法的索引参数以字节为单位，而不是以正在读取或写入的类型为单位。

为了访问同类二进制数据，即相同类型的值序列，此类定义了可以创建给定字节缓冲区视图的方法。 视图缓冲区只是另一个缓冲区，其内容由字节缓冲区支持。 对字节缓冲区内容的更改将在视图缓冲区中可见，反之亦然； 两个缓冲区的位置、界限和标记值是独立的。
例如， asFloatBuffer方法创建FloatBuffer类的一个实例，该类由调用该方法的字节缓冲区支持。 为char 、 short 、 int 、 long和double类型定义了相应的视图创建方法。

与上述特定类型的get和put方法系列相比，视图缓冲区具有三个重要优势：

1. 视图缓冲区的索引不是根据字节而是根据其值的类型特定大小；
2. 视图缓冲区提供相对批量的get和put方法，可以在缓冲区和数组或其他相同类型的缓冲区之间传输连续的值序列； 和
3. 视图缓冲区可能更高效，因为当且仅当其后备字节缓冲区是直接的时，它才是直接的。

视图缓冲区的字节顺序固定为创建视图时其字节缓冲区的字节顺序。

## 链式调用

此类中没有返回值的方法被指定为返回调用它们的缓冲区，这允许链式方法调用。比如如下的代码：

```java
bb.putInt(0xCAFEBABE);
bb.putShort(3);
bb.putShort(45);
```

例如，可以替换为单个语句

```java
bb.putInt(0xCAFEBABE).putShort(3).putShort(45);
```